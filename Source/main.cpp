/**
  * This example application is provided with no restrictions on non-commercial use.
  * You are free to modify, distribute, and share this example application, but
  * not to use it commercially or as a source of income.
  */

#include "gsound/GSound.h"

#include <cstdio>
#include <sstream>

#if defined(GSOUND_PLATFORM_APPLE)
	#include <GLUT/glut.h>
	#include <mach-o/dyld.h>
	#include <limits.h>
#elif defined(GSOUND_PLATFORM_WINDOWS)
	#define NOMINMAX
	#include <Windows.h>
	#include "GL/glut.h"
#endif

#include "Mesh.h"
#include "SoundDemo.h"


#define WINDOW_WIDTH	1024
#define WINDOW_HEIGHT	768

#define CAMERA_SPEED 15
#define LISTENER_SPEED 5

#define KEY_LOOK_SPEED 700

#define NUM_DEMOS 5

#define PATH_TO_TEST_DATA String("Data/")


using namespace gsound;
using gsound::util::Timer;


class Camera
{
	public:
		
		Camera()
			:	fov( 45.0f )
		{
		}
		
		Real fov;
		Real pitch;
		Real yaw;
		
		Transformation3 transformation;
		
		Vector3 velocity;
		Vector3 acceleration;
		
};



//##########################################################################################
//##########################################################################################
//############		
//############		Variable Declarations
//############		
//##########################################################################################
//##########################################################################################


SoundPlayer* player;
// A pointer to the class which is performing sound propagation.
SoundPropagator* propagator;

// A pointer to a class representing the sound output device that is going to be used.
SoundOutputDevice* outputDevice;

SoundOutputDevice* inputDevice;

// A pointer to the class which renders the sound propagation audio.
SoundPropagationRenderer* renderer;

// a cache used to hold debug drawing information generated by the sound propagator.
DebugDrawingCache debugDrawingCache;

// A buffer of propagation paths produced by the sound propagator.
SoundPropagationPathBuffer pathBuffer;

// An array of sound demos.
SoundDemo demos[NUM_DEMOS];

// The current demo index.
Index currentDemoIndex = 0;

// The camera for the graphics drawing.
Camera camera;

// Whether or not the camera is attached to the listener.
Bool cameraAttachedToListener = true;

// The properties of the camera's light.
Float lightAmbient[4] = { 0.2, 0.2, 0.2, 1.0 };
Float lightDiffuse[4] = { 0.5, 0.5, 0.5, 1.0 };
Float lightPosition[4] = { 0, 0, 0, 1.0 };
Float lightAttenuation[3] = { 0.5, 0.4, 0.0 };


// Sound Propagation properties.
Size maxDepth = 4;
Size numListenerProbeRays = 1000;
Size numSourceProbeRays = 100;


// Arrays representing the current state of the keyboard, TRUE == key pressed.
Bool keys[256];
Bool specialKeys[256];

// A class used to provide frame timing.
Timer timer;
Timer frameTimer;


//##########################################################################################
//##########################################################################################
//############		
//############		Function Declarations
//############		
//##########################################################################################
//##########################################################################################


// Initialize all sound propagation state.
void initializeSoundPropagation();


// Keyboard and mouse input handling methods.
void handleMouseInput( float newDx, float newDy );
void handleKeyDown( unsigned char keyChar, int x, int y );
void handleKeyUp( unsigned char keyChar, int x, int y );
void handleSpecialKeyDown( int keyChar, int x, int y );
void handleSpecialKeyUp( int keyChar, int x, int y );
void mouseMotionCallback( int x, int y );
void handleInput();


// The main update function.
void update();


// Drawing functions.
void initializeOpenGL( Size windowWidth, Size windowHeight );
void drawDebugCache( const DebugDrawingCache& debugDrawingCache );
void setCameraMatrixFromTransformation( const Transformation3& t, Float cameraMatrix[16] );
void draw();


// Sets the current working directory to the one that contains the executable.
void setCurrentDirectory();


//##########################################################################################
//##########################################################################################
//############		
//############		Main Method
//############		
//##########################################################################################
//##########################################################################################




int main ( int argc, char** argv )
{
	glutInit( &argc, argv );
	glutInitDisplayMode( GLUT_DOUBLE | GLUT_RGBA | GLUT_DEPTH );
	glutInitWindowSize( WINDOW_WIDTH, WINDOW_HEIGHT );
	
	glutCreateWindow("Virtual Echolocation Tech Demo");
	
	initializeOpenGL( WINDOW_WIDTH, WINDOW_HEIGHT );
	
	glutDisplayFunc( update );
	glutIdleFunc( update );
	
	glutKeyboardFunc( handleKeyDown );
	glutKeyboardUpFunc( handleKeyUp );
	glutSpecialFunc( handleSpecialKeyDown );
	glutSpecialUpFunc( handleSpecialKeyUp );
	glutPassiveMotionFunc( mouseMotionCallback );
	glutSetCursor( GLUT_CURSOR_NONE );
	
	setCurrentDirectory();

	initializeSoundPropagation();
	
	glutMainLoop();
	
    return 0;
}




//##########################################################################################
//##########################################################################################
//############		
//############		Sound Propagation Functions
//############		
//##########################################################################################
//##########################################################################################




void setCurrentDemo( Index demoIndex )
{
	if ( demoIndex >= NUM_DEMOS )
	{
		printf("\nInvalid demo index: %d",demoIndex);
		return;
	}
	
	currentDemoIndex = demoIndex;
	cameraAttachedToListener = true;
	camera.transformation.position = demos[currentDemoIndex].listener.getPosition();
	camera.transformation.orientation = demos[currentDemoIndex].listener.getOrientation();
	camera.velocity = demos[currentDemoIndex].listener.getVelocity();
	camera.acceleration = Vector3();
	camera.yaw = demos[currentDemoIndex].yaw;
	camera.pitch = demos[currentDemoIndex].pitch;
}


String pathfile;

void initializeSoundPropagation()
{
	//***************************************************************************************
	// Initialize every demo.
	// Create a new sound propagator.
	propagator = new SoundPropagator();
	setPathToTestData( PATH_TO_TEST_DATA );
	
	demos[0] = loadIndoorScene();
	demos[1] = loadOutdoorScene();
	demos[2] = loadDesertScene();
	demos[3] = loadHelicopterScene();
	demos[4] = loadCathedralScene();
	//demos[4] = loadCathedralScene2();
	
	setCurrentDemo( 0 );
	pathfile = "path1.txt";
	
	//***************************************************************************************
	// Enable/Disable various parts of the sound propagation algorithm
	
	
	
	propagator->setDirectSoundIsEnabled( true );
	//propagator->setDirectSoundIsEnabled( false );
	//propagator->setDirectSoundIsEnabled( true );
	propagator->setTransmissionIsEnabled( true );
	propagator->setReflectionIsEnabled( true );
	propagator->setDiffractionIsEnabled( true );
	propagator->setReverbIsEnabled( true );
	
	//***************************************************************************************
	// Enable/Disable different types of debug drawing.
	
	// Disable drawing probe rays that hit surfaces.
	debugDrawingCache.setFiniteProbeRaysAreEnabled( false );
	
	// Disable drawing probe rays that don't hit surfaces.
	debugDrawingCache.setInfiniteProbeRaysAreEnabled( false );
	
	// Enable drawing direct propagation paths.
	debugDrawingCache.setDirectPathsAreEnabled( true );
	//debugDrawingCache.setDirectPathsAreEnabled( false );
	//debugDrawingCache.setDirectPathsAreEnabled( true );
	
	// Enable drawing transmission propagation paths.
	debugDrawingCache.setTransmissionPathsAreEnabled( true );
	
	// Enable drawing reflection propagation paths.
	debugDrawingCache.setReflectionPathsAreEnabled( true );
	
	// Enable drawing diffraction propagation paths.
	debugDrawingCache.setDiffractionPathsAreEnabled( true );
	
	// Disable drawing object meshes, this is slow and is better done in a different way.
	debugDrawingCache.setObjectMeshesAreEnabled( false );
	
	// Enable drawing diffraction edges.
	debugDrawingCache.setDiffractionEdgesAreEnabled( true );
	
	// Enable drawing disconnecteddiffraction edges.
	debugDrawingCache.setDisconnectedDiffractionEdgesAreEnabled( true );
	
	// Enable drawing sound sources.
	debugDrawingCache.setSourcesAreEnabled( true );
	
	// Enable drawing listeners.
	debugDrawingCache.setListenersAreEnabled( true );
	

	
	//***************************************************************************************
	// Initialize the sound propagation renderer
	
	// Create a sound propagation renderer which renders audio for a 2-channel stereo speaker setup.
	renderer = new SoundPropagationRenderer( dsp::SpeakerConfiguration::getStereo() );
	
	// Create an object which specifies the frequency bands that are being rendered.
	FrequencyPartition frequencyPartition;
	
	// The four frequency bands will be: 0Hz to 250Hz, 250Hz to 1000Hz,
	// 1000Hz to 4000Hz, and 4000Hz to the Nyquist Frequency.
	frequencyPartition.addSplitFrequency( 250 );
	frequencyPartition.addSplitFrequency( 1000 );
	frequencyPartition.addSplitFrequency( 4000 );
	
	// Send this frequency partition to the renderer so that it knows what frequency bands to use.
	renderer->setFrequencyPartition( frequencyPartition );
	
	
	//***************************************************************************************
	// Initialize the sound output device.
	
	// Create a device manager object which enumerates all connected sound devices.
	SoundDeviceManager deviceManager;
	SoundDeviceManagerWrapper indeviceManager;
	
	// Create an object which encapsulates the functionality of sending audio to a sound output device.
	// Use the default system output device.
	outputDevice = new SoundOutputDevice( deviceManager.getDefaultOutputDeviceID() );
	//inputDevice = new SoundOutputDevice(deviceManager   );
	
	// Set the sound output device so that it gets audio from the sound propagation renderer.
	outputDevice->setInput( renderer );
	
	// Start outputing audio to the device.
	outputDevice->start();
}




void doSoundPropagation()
{
	// If the sound propagation listener is attached to the current camera position,
	// set the listener to have the same orientation/position/velocity as the camera.
	if ( cameraAttachedToListener )
	{
		demos[currentDemoIndex].listener.setOrientation( camera.transformation.orientation );
		demos[currentDemoIndex].listener.setPosition( camera.transformation.position );
		demos[currentDemoIndex].listener.setVelocity( camera.velocity );
	}
	
	// Perform sound propagation in the scene.
	propagator->propagateSound(	demos[currentDemoIndex].scene, demos[currentDemoIndex].listener,
								maxDepth, numListenerProbeRays,
								maxDepth, numSourceProbeRays, pathBuffer, debugDrawingCache );
	
	// Update the state of the sound propagation renderer.
	renderer->updatePropagationPaths( pathBuffer );
}




//##########################################################################################
//##########################################################################################
//############		
//############		Update Method
//############		
//##########################################################################################
//##########################################################################################


float upd = 2;

void update()
{
	handleInput();
	
	frameTimer.update();
	doSoundPropagation();
	frameTimer.update();
	
	timer.update();
//	upd = upd - timer.getLastInterval();
//	if(upd < 0)
//	{
//		upd = 2;
	//demos[currentDemoIndex].scene.getSource(0)->setDirection( camera.velocity );
	//demos[currentDemoIndex].scene.getSource(0)->setPosition( camera.transformation.position );
	//demos[currentDemoIndex].scene.getSource(0)->setVelocity( camera.velocity );
//demos[currentDemoIndex].scene.getSource(0)->setIsEnabled( false );
//	}
	
	draw();

}



//##########################################################################################
//##########################################################################################
//############		
//############		Keyboard Input Functions
//############		
//##########################################################################################
//##########################################################################################




void handleMouseInput( float newDx, float newDy )
{
	double dx = (double)newDx*(camera.fov/45.0f)/10.0f;
	double dy = (double)newDy*(camera.fov/45.0f)/10.0f;
	
	camera.yaw += dx;
	camera.pitch += dy;
	
	camera.transformation.orientation = Matrix3::rotationYDegrees(camera.yaw)*Matrix3::rotationXDegrees(camera.pitch);
}


std::FILE* file;
	fpos_t pos;

void handleKeyDown( unsigned char keyChar, int x, int y )
{
	keys[keyChar] = true;
	
	if ( keyChar == '\t' )
		cameraAttachedToListener = !cameraAttachedToListener;

	if ( keyChar == '0' )
	{

	demos[currentDemoIndex].scene.getSource(0)->setIsDirectional(true);

	demos[currentDemoIndex].scene.getSource(0)->setDirection( camera.transformation.position *camera.transformation.orientation );

	demos[currentDemoIndex].scene.getSource(0)->setPosition( camera.transformation.position - camera.transformation.orientation.z/50 );

		
		
		//demos[currentDemoIndex].scene.getSource(0)->setDirection( camera.transformation.position *camera.transformation.orientation );
	//demos[currentDemoIndex].scene.getSource(0)->setPosition( camera.transformation.position + Vector3( 0.01, 0.01, 0.01 )*camera.transformation.orientation );
//	demos[currentDemoIndex].scene.getSource(0)->setVelocity( camera.velocity );
	//camera.transformation.
	demos[currentDemoIndex].scene.getSource(0)->setIntensity(1);
	//propagator->setDirectSoundIsEnabled( true );
		//player->setIsLooping(false);
//player->setIsPlaying(true);
	//player->play();
	
	}

	if ( keyChar == 'i' )
	{
		file = std::fopen( pathfile.c_str(), "a" );

		std::fwrite( &camera.transformation.position.x, sizeof(Float), 1, file );
		std::fwrite( &camera.transformation.position.y, sizeof(Float), 1, file );
		std::fwrite( &camera.transformation.position.z, sizeof(Float), 1, file );

		std::fwrite( &camera.yaw, sizeof(Float), 1, file );
		std::fwrite( &camera.pitch, sizeof(Float), 1, file );

		/*std::fwrite( &camera.transformation.orientation.get(1,1), sizeof(Float), 1, file );
		std::fwrite( &camera.transformation.orientation.get(1,2), sizeof(Float), 1, file );
		std::fwrite( &camera.transformation.orientation.get(1,3), sizeof(Float), 1, file );
		std::fwrite( &camera.transformation.orientation.get(2,1), sizeof(Float), 1, file );
		std::fwrite( &camera.transformation.orientation.get(2,2), sizeof(Float), 1, file );
		std::fwrite( &camera.transformation.orientation.get(2,3), sizeof(Float), 1, file );
		std::fwrite( &camera.transformation.orientation.get(3,1), sizeof(Float), 1, file );
		std::fwrite( &camera.transformation.orientation.get(3,2), sizeof(Float), 1, file );
		std::fwrite( &camera.transformation.orientation.get(3,3), sizeof(Float), 1, file );
*/
//		Matrix3::rotationYDegrees(camera.yaw)*Matrix3::rotationXDegrees(camera.pitch);

		// Close the file.
	std::fclose( file );



	}

	if ( keyChar == 'o' )
	{
		std::FILE* file = std::fopen( pathfile.c_str(), "r" );
		fsetpos (file,&pos);
		
		gsound::Float x;
		std::fread( &x, sizeof(Float), 1, file );
		if ( feof( file)) return;
	    camera.transformation.position.x = x;
		//std::fread( &camera.transformation.position.x, sizeof(Float), 1, file );
		std::fread( &camera.transformation.position.y, sizeof(Float), 1, file );
		std::fread( &camera.transformation.position.z, sizeof(Float), 1, file );

		gsound::Float p;
		gsound::Float y;
		std::fread( &y, sizeof(Float), 1, file );
		std::fread( &p, sizeof(Float), 1, file );

		camera.yaw = y;
	    camera.pitch = p;
		camera.transformation.orientation = Matrix3::rotationYDegrees(y)*Matrix3::rotationXDegrees(p);

		fgetpos (file,&pos);
			
		// Close the file.
	std::fclose( file );

	}

	if ( keyChar == 'p' )
	{
		file = std::fopen( pathfile.c_str(), "r" );
	
    fgetpos (file,&pos);
	std::fclose( file );

	}
	
	if ( keyChar == '1' ){
		setCurrentDemo( 0 );
		pathfile = "path1.txt";}
	
	if ( keyChar == '2' ){
		setCurrentDemo( 1 );
		pathfile = "path2.txt";}
	
	if ( keyChar == '3' ){
		setCurrentDemo( 2 );
		pathfile = "path3.txt";}
	
	if ( keyChar == '4' ){
		setCurrentDemo( 3 );
		pathfile = "path4.txt";}
	
	if ( keyChar == '5' ){
		setCurrentDemo( 4 );
		pathfile = "path5.txt";}

	if ( keyChar == '6' )
	{
	FrequencyResponse f1(0.98, 0.98, 0.98, 0.97, 0.96, 0.95, 0.93, 0.92); 
	FrequencyResponse f0(0, 0, 0, 0, 0, 0, 0, 0); 
	SoundMaterial newmat(f1,f0,f0);
	demos[currentDemoIndex].scene.getObject(0)->getMesh()->setMaterial(0,newmat);
	}

	if ( keyChar == '7' )
	{
	FrequencyResponse f1(0.66, 0.72, 0.78, 0.83, 0.91, 0.90, 0.89, 0.87); 
	FrequencyResponse f0(0, 0, 0, 0, 0, 0, 0, 0); 
	SoundMaterial newmat(f1,f0,f0);
	demos[currentDemoIndex].scene.getObject(0)->getMesh()->setMaterial(0,newmat);
	}
	
	if ( keyChar == 'g' || keyChar == 'G' )
		propagator->setDirectSoundIsEnabled( !propagator->getDirectSoundIsEnabled() );
	
	if ( keyChar == 't' || keyChar == 'T' )
		propagator->setTransmissionIsEnabled( !propagator->getTransmissionIsEnabled() );
	
	if ( keyChar == 'r' || keyChar == 'R' )
		propagator->setReflectionIsEnabled( !propagator->getReflectionIsEnabled() );
	
	if ( keyChar == 'f' || keyChar == 'F' )
		propagator->setDiffractionIsEnabled( !propagator->getDiffractionIsEnabled() );
	
	if ( keyChar == 'v' || keyChar == 'V' )
		propagator->setReverbIsEnabled( !propagator->getReverbIsEnabled() );
	
	if ( keyChar == '-' )
		maxDepth = math::clamp( maxDepth, Size(1), Size(5) ) - 1;
	else if ( keyChar == '=' )
		maxDepth = math::clamp( maxDepth + 2, Size(1), Size(5) ) - 1;
	
	if ( keyChar == '[' )
		numListenerProbeRays = math::max( numListenerProbeRays / 2, Size(1) );
	else if ( keyChar == ']' )
		numListenerProbeRays = math::min( numListenerProbeRays * 2, Size(100000) );
	
	if ( keyChar == ',' )
		numSourceProbeRays = math::max( numSourceProbeRays / 2, Size(1) );
	else if ( keyChar == '.' )
		numSourceProbeRays = math::min( numSourceProbeRays * 2, Size(100000) );
}




void handleKeyUp( unsigned char keyChar, int x, int y )
{
	keys[keyChar] = false;
	if ( keyChar == '0' )
		demos[currentDemoIndex].scene.getSource(0)->setIntensity(0);// setIsEnabled( false );
		//player->stop();
}




void handleSpecialKeyDown( int keyChar, int x, int y )
{
	specialKeys[keyChar] = true;
}




void handleSpecialKeyUp( int keyChar, int x, int y )
{
	specialKeys[keyChar] = false;
}




void mouseMotionCallback( int x, int y )
{
	static bool hasFirstPoint = false;
	static int previousX = 0;
	static int previousY = 0;
	
	if ( !hasFirstPoint )
	{
		previousX = x;
		previousY = y;
		
		hasFirstPoint = true;
		return;
	}
	
	int dx = x - previousX;
	int dy = previousY - y;
	
	handleMouseInput( dx, -dy );
	
	previousX = x;
	previousY = y;
}




void handleInput()
{
	camera.acceleration = Vector3::ZERO;
	
	if ( keys['w'] )
		camera.acceleration -= camera.transformation.orientation.z*CAMERA_SPEED;
	
	if ( keys['s'] )
		camera.acceleration += camera.transformation.orientation.z*CAMERA_SPEED;
	
	if ( keys['a'] )
		camera.acceleration -= camera.transformation.orientation.x*CAMERA_SPEED;
	
	if ( keys['d'] )
		camera.acceleration += camera.transformation.orientation.x*CAMERA_SPEED;
	
	camera.velocity += camera.acceleration*timer.getLastInterval() - camera.velocity*5*timer.getLastInterval();
	camera.transformation.position += camera.velocity*timer.getLastInterval();
	
	if ( specialKeys[GLUT_KEY_LEFT] )
		handleMouseInput( -KEY_LOOK_SPEED*timer.getLastInterval(), 0 );
	
	if ( specialKeys[GLUT_KEY_RIGHT] )
		handleMouseInput( KEY_LOOK_SPEED*timer.getLastInterval(), 0 );
	
	if ( specialKeys[GLUT_KEY_UP] )
		handleMouseInput( 0, -KEY_LOOK_SPEED*timer.getLastInterval() );
	
	if ( specialKeys[GLUT_KEY_DOWN] )
		handleMouseInput( 0, KEY_LOOK_SPEED*timer.getLastInterval() );
}




//##########################################################################################
//##########################################################################################
//############		
//############		Drawing Functions
//############		
//##########################################################################################
//##########################################################################################




void initializeOpenGL( Size windowWidth, Size windowHeight )
{
	glClearColor( 0.5f, 0.5f, 0.5f, 0.0f );	// Black background
	glClearDepth( 1.0f );					// Depth buffer setup
	
	glColorMaterial( GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE );
	glEnable( GL_COLOR_MATERIAL );
	
	glDepthFunc( GL_LEQUAL );	// The type of depth test to do
	glHint( GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST );
	glCullFace( GL_BACK );		// Set Culling Face To Back Face
	glShadeModel( GL_SMOOTH );	// Enable smooth shading
	glEnable( GL_DEPTH_TEST );
	//glEnable( GL_CULL_FACE );
	glEnable( GL_BLEND );
	glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );
	
	glEnable( GL_TEXTURE_2D );
	glEnable( GL_LIGHTING );
}




void drawDebugCache( const DebugDrawingCache& debugDrawingCache )
{
	if ( debugDrawingCache.getFiniteProbeRaysAreEnabled() )
	{
		const ArrayList<DebugDrawingCache::FiniteProbeRay>& finiteProbeRays = debugDrawingCache.getFiniteProbeRays();
		
		glLineWidth(1.0);
		glVertexPointer( 3, GL_FLOAT, 0, finiteProbeRays.getArrayPointer() );
		glEnableClientState( GL_VERTEX_ARRAY );
		
		glColor4f( 0.0f, 0.0f, 1.0f, 1.0f );
		glDrawArrays( GL_LINES, 0, GLsizei(finiteProbeRays.getSize()*2) );
		glDisableClientState( GL_VERTEX_ARRAY );
	}
	
	if ( debugDrawingCache.getInfiniteProbeRaysAreEnabled() )
	{
		const ArrayList<Ray3>& infiniteProbeRays = debugDrawingCache.getInfiniteProbeRays();
		
		glLineWidth(1.0);
		glColor4f( 0.0f, 0.0f, 1.0f, 1.0f );
		
		glBegin( GL_LINES );
		
		const Real rayLength = 1000.0f;
		
		for ( Index i = 0; i < infiniteProbeRays.getSize(); i++ )
		{
			const Ray3& ray = infiniteProbeRays[i];
			
			glVertex3f( ray.origin.x, ray.origin.y, ray.origin.z );
			glVertex3f( ray.origin.x + ray.direction.x*rayLength,
						ray.origin.y + ray.direction.y*rayLength,
						ray.origin.z + ray.direction.z*rayLength );
		}
		
		glEnd();
	}
	
	if ( debugDrawingCache.getDirectPathsAreEnabled() )
	{
		const ArrayList<DebugDrawingCache::DirectPath>& directPaths = debugDrawingCache.getDirectPaths();
		
		glLineWidth(1.0);
		glVertexPointer( 3, GL_FLOAT, 0, directPaths.getArrayPointer() );
		glEnableClientState( GL_VERTEX_ARRAY );
		
		glColor4f( 1.0f, 1.0f, 1.0f, 1.0f );
		glDrawArrays( GL_LINES, 0, GLsizei(directPaths.getSize()*2) );
		glDisableClientState( GL_VERTEX_ARRAY );
	}
	
	if ( debugDrawingCache.getTransmissionPathsAreEnabled() )
	{
		const ArrayList<DebugDrawingCache::DirectPath>& transmissionPaths = debugDrawingCache.getTransmissionPaths();
		
		glLineWidth(1.0);
		glVertexPointer( 3, GL_FLOAT, 0, transmissionPaths.getArrayPointer() );
		glEnableClientState( GL_VERTEX_ARRAY );
		
		glColor4f( 0.0f, 1.0f, 1.0f, 1.0f );
		glDrawArrays( GL_LINES, 0, GLsizei(transmissionPaths.getSize()*2) );
		glDisableClientState( GL_VERTEX_ARRAY );
	}
	
	if ( debugDrawingCache.getReflectionPathsAreEnabled() )
	{
		const ArrayList<DebugDrawingCache::IndirectPath>& reflectionPaths = debugDrawingCache.getReflectionPaths();
		
		glLineWidth(1.0);
		glColor4f( 0.0f, 1.0f, 0.0f, 1.0f );
		
		for ( Index i = 0; i < reflectionPaths.getSize(); i++ )
		{
			const DebugDrawingCache::IndirectPath& path = reflectionPaths[i];
			const ArrayList<Vector3>& pathPoints= path.points;
			
			glBegin( GL_LINE_STRIP );
			
			for ( Index j = 0; j < pathPoints.getSize(); j++ )
				glVertex3f( pathPoints[j].x, pathPoints[j].y, pathPoints[j].z );
			
			glEnd();
		}
	}
	
	if ( debugDrawingCache.getDiffractionPathsAreEnabled() )
	{
		const ArrayList<DebugDrawingCache::IndirectPath>& diffractionPaths = debugDrawingCache.getDiffractionPaths();
		
		glLineWidth(1.0);
		glColor4f( 1.0f, 1.0f, 0.0f, 1.0f );
		
		for ( Index i = 0; i < diffractionPaths.getSize(); i++ )
		{
			const DebugDrawingCache::IndirectPath& path = diffractionPaths[i];
			const ArrayList<Vector3>& pathPoints= path.points;
			
			glBegin( GL_LINE_STRIP );
			
			for ( Index j = 0; j < pathPoints.getSize(); j++ )
				glVertex3f( pathPoints[j].x, pathPoints[j].y, pathPoints[j].z );
			
			glEnd();
		}
	}
	
	if ( debugDrawingCache.getObjectMeshesAreEnabled() )
	{
		const ArrayList<DebugDrawingCache::ObjectMesh>& objectMeshes = debugDrawingCache.getObjectMeshes();
		
		glColor4f( 1.0f, 1.0f, 0.0f, 1.0f );
		
		math::RandomVariable<Real> rand( 27 );
		
		for ( Index i = 0; i < objectMeshes.getSize(); i++ )
		{
			const DebugDrawingCache::ObjectMesh& mesh = objectMeshes[i];
			
			glVertexPointer( 3, GL_FLOAT, 0, mesh.vertices.getArrayPointer() );
			glEnableClientState( GL_VERTEX_ARRAY );
			
			
			const ArrayList<SoundTriangle>& triangles = mesh.triangles;
			
			glBegin( GL_TRIANGLES );
			for ( Index j = 0; j < triangles.getSize(); j++ )
			{
				Real a = rand.sample( 0.5, 0.75 );
				
				glColor4f( a, a, a, 1.0f );
				glArrayElement( GLint(triangles[j].v[0]) );
				glArrayElement( GLint(triangles[j].v[1]) );
				glArrayElement( GLint(triangles[j].v[2]) );
			}
			glEnd();
			
			glDisableClientState( GL_VERTEX_ARRAY );
		}
	}
	
	if ( debugDrawingCache.getSourcesAreEnabled() )
	{
		const ArrayList<const SoundSource*> sources = debugDrawingCache.getSources();
		
		glPointSize( 10.0 );
		glColor4f( 1.0f, 0.0f, 1.0f, 1.0f );
		glBegin( GL_POINTS );
		
		for ( Index i = 0; i < sources.getSize(); i++ )
		{
			glVertex3f( sources[i]->getPosition().x, sources[i]->getPosition().y, sources[i]->getPosition().z );
		}
		
		glEnd();
	}
	
	if ( debugDrawingCache.getListenersAreEnabled() )
	{
		const ArrayList<const SoundListener*> listeners = debugDrawingCache.getListeners();
		
		glPointSize( 10.0 );
		glColor4f( 1.0f, 1.0f, 1.0f, 1.0f );
		glBegin( GL_POINTS );
		
		for ( Index i = 0; i < listeners.getSize(); i++ )
		{
			glVertex3f( listeners[i]->getPosition().x, listeners[i]->getPosition().y, listeners[i]->getPosition().z );
		}
		
		glEnd();
	}
}




void setCameraMatrixFromTransformation( const Transformation3& t, Float cameraMatrix[16] )
{
	cameraMatrix[0] = t.orientation.x.x;
	cameraMatrix[1] = t.orientation.y.x;
	cameraMatrix[2] = t.orientation.z.x;
	cameraMatrix[3] = 0.0f;
	cameraMatrix[4] = t.orientation.x.y;
	cameraMatrix[5] = t.orientation.y.y;
	cameraMatrix[6] = t.orientation.z.y;
	cameraMatrix[7] = 0.0f;
	cameraMatrix[8] = t.orientation.x.z;
	cameraMatrix[9] = t.orientation.y.z;
	cameraMatrix[10] = t.orientation.z.z;
	cameraMatrix[11] = 0.0f;
	cameraMatrix[12] = -math::dot( t.position, t.orientation.x );
	cameraMatrix[13] = -math::dot( t.position, t.orientation.y );
	cameraMatrix[14] = -math::dot( t.position, t.orientation.z );
	cameraMatrix[15] = 1.0f;
}




void setObjectMatrixFromTransformation( const Transformation3& t, Float objectMatrix[16] )
{
	objectMatrix[0] = t.orientation.x.x*t.scale;
	objectMatrix[1] = t.orientation.x.y*t.scale;
	objectMatrix[2] = t.orientation.x.z*t.scale;
	objectMatrix[3] = 0.0f;
	objectMatrix[4] = t.orientation.y.x*t.scale;
	objectMatrix[5] = t.orientation.y.y*t.scale;
	objectMatrix[6] = t.orientation.y.z*t.scale;
	objectMatrix[7] = 0.0f;
	objectMatrix[8] = t.orientation.z.x*t.scale;
	objectMatrix[9] = t.orientation.z.y*t.scale;
	objectMatrix[10] = t.orientation.z.z*t.scale;
	objectMatrix[11] = 0.0f;
	objectMatrix[12] = t.position.x;
	objectMatrix[13] = t.position.y;
	objectMatrix[14] = t.position.z;
	objectMatrix[15] = 1.0f;
}




void drawScene( const SoundScene& scene )
{
	for ( Index i = 0; i < scene.getNumberOfObjects(); i++ )
	{
		SoundObject* object = scene.getObject(i);
		
		glPushMatrix();
		
		Float objectMatrix[16];
		setObjectMatrixFromTransformation( object->getTransformation(), objectMatrix );
		
		glMultMatrixf( objectMatrix );
		
		SoundMesh* soundMesh = object->getMesh();
		Mesh* mesh = (Mesh*)soundMesh->getUserData();
		mesh->draw();
		
		
		glPopMatrix();
	}
}




void renderString( const String& string, void* font )
{
	for ( Index i = 0; i < string.length(); i++ )
		glutBitmapCharacter( font, string[i] );
}




template < typename T >
String lexicalCast( T number )
{
	std::stringstream stream;
	stream << number;
	return stream.str();
}




template <>
String lexicalCast( Bool boolean )
{
	if ( boolean )
		return String("On");
	else
		return String("Off");
}




void drawUI()
{
	glMatrixMode( GL_PROJECTION );
	glPushMatrix();
	glLoadIdentity();
	gluOrtho2D( 0, WINDOW_WIDTH, 0, WINDOW_HEIGHT );
	
	glMatrixMode( GL_MODELVIEW );
	glPushMatrix();
	glLoadIdentity();
	
	glColor4f( 0.0, 0.0, 0.0, 0.5 );
	
	//glBegin( GL_QUADS );
		
//		glVertex2f( 0, WINDOW_HEIGHT );
	//	glVertex2f( 0, WINDOW_HEIGHT - 155 );
	//	glVertex2f( 275, WINDOW_HEIGHT - 155 );
	//	glVertex2f( 275, WINDOW_HEIGHT );
		
	//	glVertex2f( 0, 0 );
	//	glVertex2f( 0, 295 );
	//	glVertex2f( 280, 295 );
	//	glVertex2f( 280, 0 );
		
//	glEnd();
	
	glColor3f( 0.0, 1.0, 0.0 );
	
	//**************************************************************************************
	
	// Current Demo
	glRasterPos2i( 10, WINDOW_HEIGHT - 20 );
	renderString("Demo: " + demos[currentDemoIndex].name, GLUT_BITMAP_HELVETICA_18);
	
	// Number of Triangles
	glRasterPos2i( 10, WINDOW_HEIGHT - 45 );
	renderString("Num Triangles: " + lexicalCast(demos[currentDemoIndex].getNumberOfTriangles()), GLUT_BITMAP_HELVETICA_18);
	
	// Path Depth
	glRasterPos2i( 10, WINDOW_HEIGHT - 70 );
	renderString("Max Depth: " + lexicalCast(maxDepth), GLUT_BITMAP_HELVETICA_18);
	
	// Num Listener Rays
	glRasterPos2i( 10, WINDOW_HEIGHT - 95 );
	renderString("Num Listener Probe Rays: " + lexicalCast(numListenerProbeRays), GLUT_BITMAP_HELVETICA_18);
	
	// Num Source Rays
	glRasterPos2i( 10, WINDOW_HEIGHT - 120 );
	renderString("Num Reverb Rays: " + lexicalCast(numSourceProbeRays), GLUT_BITMAP_HELVETICA_18);
	
	// Num Source Rays
	glRasterPos2i( 10, WINDOW_HEIGHT - 145 );
	renderString("Frame Time: " + lexicalCast(frameTimer.getLastInterval()*1000) + " ms", GLUT_BITMAP_HELVETICA_18);
	
	
	//**************************************************************************************
	
	
	glRasterPos2i( 10, 15 );
	renderString("5 = Cathedral Demo", GLUT_BITMAP_HELVETICA_12);
	
	glRasterPos2i( 10, 30 );
	renderString("4 = Simple Outdoor Demo", GLUT_BITMAP_HELVETICA_12);
	
	glRasterPos2i( 10, 45 );
	renderString("3 = Outdoor Demo 2", GLUT_BITMAP_HELVETICA_12);
	
	glRasterPos2i( 10, 60 );
	renderString("2 = Outdoor Demo 1", GLUT_BITMAP_HELVETICA_12);
	
	glRasterPos2i( 10, 75 );
	renderString("1 = Simple Indoor Demo", GLUT_BITMAP_HELVETICA_12);
	

	glRasterPos2i( 10, 90 );
	renderString("0 = Hold to 'Tongue Click'" , GLUT_BITMAP_HELVETICA_12);

	glRasterPos2i( 10, 105 );
	renderString("V = Toggle Reverb: " + lexicalCast(propagator->getReverbIsEnabled()), GLUT_BITMAP_HELVETICA_12);
	
	glRasterPos2i( 10, 120 );
	renderString("F = Toggle Diffraction: " + lexicalCast(propagator->getDiffractionIsEnabled()), GLUT_BITMAP_HELVETICA_12);
	
	glRasterPos2i( 10, 135 );
	renderString("R = Toggle Reflection: " + lexicalCast(propagator->getReflectionIsEnabled()), GLUT_BITMAP_HELVETICA_12);
	
	glRasterPos2i( 10, 150 );
	renderString("T = Toggle Transmission: " + lexicalCast(propagator->getTransmissionIsEnabled()), GLUT_BITMAP_HELVETICA_12);
	
	glRasterPos2i( 10, 165 );
	renderString("G = Toggle Direct Sound: " + lexicalCast(propagator->getDirectSoundIsEnabled()), GLUT_BITMAP_HELVETICA_12);
	
	glRasterPos2i( 10, 190 );
	//renderString("Tab = Detach Camera From Listener", GLUT_BITMAP_HELVETICA_12);
	renderString("6 = scene material is brick, 7 = scene material is plywood", GLUT_BITMAP_HELVETICA_12);
	
	glRasterPos2i( 10, 215 );
	renderString(", and . = Decrease/Increase Num Reverb Rays", GLUT_BITMAP_HELVETICA_12);
	
	glRasterPos2i( 10, 230 );
	renderString("[ and ] = Decrease/Increase Num Listener Rays", GLUT_BITMAP_HELVETICA_12);
	
	glRasterPos2i( 10, 245 );
	renderString("- and = = Decrease/Increase Max Path Depth", GLUT_BITMAP_HELVETICA_12);
	
	glRasterPos2i( 10, 260 );
	renderString("Arrows = Turn", GLUT_BITMAP_HELVETICA_12);
	
	glRasterPos2i( 10, 275 );
	renderString("W, A, S, D = Move", GLUT_BITMAP_HELVETICA_12);
	
	
	//**************************************************************************************
	
	glMatrixMode( GL_MODELVIEW );
	glPopMatrix();
	
	glMatrixMode( GL_PROJECTION );
	glPopMatrix();
}




void draw()
{
	// Clear the color and depth buffers.
	glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
	
	// Setup the projection matrix for the camera.
	glMatrixMode( GL_PROJECTION );
    glLoadIdentity();
    gluPerspective( camera.fov, ((float)WINDOW_WIDTH/(float)WINDOW_HEIGHT), 0.1f, 1000.0f );
	
	// Setup the model view matrix for the camera.
	glMatrixMode( GL_MODELVIEW );
	glLoadIdentity();
	
	// Setup the view matrix for the camera.
	Float cameraMatrix[16];
	setCameraMatrixFromTransformation( camera.transformation, cameraMatrix );
	
	glLightfv( GL_LIGHT1, GL_POSITION, lightPosition );
	
	glMultMatrixf( cameraMatrix );
	
	
	// Setup a light at the camera's position.
	glEnable( GL_LIGHTING );
	glEnable( GL_LIGHT1 );
	glLightfv( GL_LIGHT1, GL_AMBIENT, lightAmbient );
	glLightfv( GL_LIGHT1, GL_DIFFUSE, lightDiffuse );
	glLightfv( GL_LIGHT1, GL_CONSTANT_ATTENUATION, &lightAttenuation[0] );
	glLightfv( GL_LIGHT1, GL_LINEAR_ATTENUATION, &lightAttenuation[1] );
	glLightfv( GL_LIGHT1, GL_QUADRATIC_ATTENUATION, &lightAttenuation[2] );
	
	
	// Draw the scene.
	drawScene( demos[currentDemoIndex].scene );
	
	glDisable( GL_LIGHTING );
	
	// Draw the debugging information for sound propagation.
	drawDebugCache( debugDrawingCache );
	
	drawUI();
	
	// Display the rendered output.
	glutSwapBuffers();
}




//##########################################################################################
//##########################################################################################
//############		
//############		Current Working Directory Set Method
//############		
//##########################################################################################
//##########################################################################################




/// Set the current working directory to be the directory containing the executable.
void setCurrentDirectory()
{
	Size bufferSize = 1024;
	
#if defined(GSOUND_PLATFORM_APPLE)
	char pathToExecutable[1024];
	_NSGetExecutablePath(pathToExecutable, (uint32_t*)&bufferSize);
#elif defined(GSOUND_PLATFORM_WINDOWS)
	TCHAR pathToExecutable[1024];
	bufferSize = GetModuleFileName(NULL, pathToExecutable, 1024);
#endif
	
	Index i;
	for ( i = 0; pathToExecutable[i] != '\0'; i++ );
	
	for ( ; i >= 1; i-- )
	{
#if defined(GSOUND_PLATFORM_APPLE)
		if ( pathToExecutable[i] == '/' )
#elif defined(GSOUND_PLATFORM_WINDOWS)
		if ( pathToExecutable[i] == '/' || pathToExecutable[i] == '\\' )
#endif
		{
			pathToExecutable[i+1] = '\0';
			break;
		}
	}
	
#if defined(GSOUND_PLATFORM_APPLE)
	chdir( pathToExecutable );
#elif defined(GSOUND_PLATFORM_WINDOWS)
	SetCurrentDirectory( pathToExecutable );
#endif
}

